# 二叉树

## 代码随想录

https://github.com/youngyangyang04/leetcode-master

### 二叉树理论基础

1. 满二叉树
   满二叉树：如果一颗二叉树只有度位 0 的节点和度为 2 的节点，并且度为 0 的节点在同一层上，则这颗二叉树为满二叉树。
   也可以说，第 k 层上就会有`2^(K - 1)`个节点。
2. 完全二叉树
   什么是完全二叉树？
   完全二叉树的定义如下：在满清二叉树中，除了最底层节点可能没填满，其余每层系欸但书都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层外第 h 层，则该层包含`1 ~ 2 ^ (h - 1)`个节点。
3. 二叉搜索树
   二叉搜索树是一个有序树。
   - 若它的左子树不空，则左子树上的所有节点的值均小于他的根节点的值；
   - 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
   - 它的左右子树也分别为二叉排序树
4. 平衡二叉搜索树
   平衡二叉搜索树，又称为 AVL 树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树。

### 1.二叉树的递归遍历

1. 二叉树的前序遍历

   ```java
    class Solution {
        public List<Integer> preorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<Integer>();
            preorder(root, result);
            return result;
        }

        public void preorder(TreeNode root, List<Integer> result) {
            if (root == null) {
                return;
            }
            result.add(root.val);
            preorder(root.left, result);
            preorder(root.right, result);
        }
    }
   ```

2. 二叉树的后序遍历

   ```java
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            inorder(root, res);
            return res;
        }

        void inorder(TreeNode root, List<Integer> list) {
            if (root == null) {
                return;
            }
            inorder(root.left, list);
            list.add(root.val);             // 注意这一句
            inorder(root.right, list);
        }
    }
   ```

3. 二叉树的中序遍历

   ```java
   class Solution {
       public List<Integer> postorderTraversal(TreeNode root) {
           List<Integer> res = new ArrayList<>();
           postorder(root, res);
           return res;
       }

       void postorder(TreeNode root, List<Integer> list) {
           if (root == null) {
               return;
           }
           postorder(root.left, list);
           postorder(root.right, list);
           list.add(root.val);             // 注意这一句
       }
   }
   ```

### 2.二叉树的迭代遍历

1. 二叉树的前序遍历
   ```java
    class Solution {
        public List<Integer> preorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();
            if (root == null){
                return result;
            }
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);
            while (!stack.isEmpty()){
                TreeNode node = stack.pop();
                result.add(node.val);
                if (node.right != null){
                    stack.push(node.right);
                }
                if (node.left != null){
                    stack.push(node.left);
                }
            }
            return result;
        }
    }
   ```
2. 二叉树的后序遍历
   ```java
    class Solution {
        public List<Integer> postorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();
            if (root == null){
                return result;
            }
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);
            while (!stack.isEmpty()){
                TreeNode node = stack.pop();
                result.add(node.val);
                if (node.left != null){
                    stack.push(node.left);
                }
                if (node.right != null){
                    stack.push(node.right);
                }
            }
            Collections.reverse(result);
            return result;
        }
    }
   ```
3. 二叉树的中序遍历
   ```java
   class Solution {
       public List<Integer> inorderTraversal(TreeNode root) {
           List<Integer> result = new ArrayList<>();
           if (root == null){
               return result;
           }
           Stack<TreeNode> stack = new Stack<>();
           TreeNode cur = root;
           while (cur != null || !stack.isEmpty()){
               if (cur != null){
                   stack.push(cur);
                   cur = cur.left;
               }else{
                   cur = stack.pop();
                   result.add(cur.val);
                   cur = cur.right;
               }
           }
           return result;
       }
   }
   ```

### 3.二叉树的统一迭代法

迭代法前序遍历代码如下:

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```

迭代法中序遍历代码如下:

```java
class Solution {
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> st = new Stack<>();
    if (root != null) st.push(root);
    while (!st.empty()) {
        TreeNode node = st.peek();
        if (node != null) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
            st.push(node);                          // 添加中节点
            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.peek();    // 重新取出栈中元素
            st.pop();
            result.add(node.val); // 加入到结果集
        }
    }
    return result;
}
}
```

迭代法后序遍历代码如下:

```java
class Solution {
   public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）

            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
   }
}
```

### 4.二叉树的层序遍历

```java
public void checkFun02(TreeNode node) {
    if (node == null) return;
    Queue<TreeNode> que = new LinkedList<TreeNode>();
    que.offer(node);

    while (!que.isEmpty()) {
        List<Integer> itemList = new ArrayList<Integer>();
        int len = que.size();

        while (len > 0) {
            TreeNode tmpNode = que.poll();
            itemList.add(tmpNode.val);

            if (tmpNode.left != null) que.offer(tmpNode.left);
            if (tmpNode.right != null) que.offer(tmpNode.right);
            len--;
        }

        resList.add(itemList);
    }

}
```

### 5.翻转二叉树（226）

翻转一棵二叉树。

```java
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.LinkedList;

public class ReverseTree {
    public TreeNode reverseTree(TreeNode root) {
        if (root == null)
            return root;
        swap(root);
        reverseTree(root.right);
        reverseTree(root.left);
        return root;
    }

    public void swap(TreeNode node) {
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
    }

    public TreeNode inverseTree(TreeNode root) {
        if (root == null)
            return root;
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.peek();
            if (node != null) {
                stack.poll();
                if (node.right != null) stack.push(node.right);
                if (node.left != null) stack.push(node.left);
                stack.push(node);
                stack.push(null);
            } else {
                stack.poll();
                node = stack.peek();
                stack.poll();
                swap(node);
            }
        }
        return root;
    }

    public TreeNode inverseTree2(TreeNode root) {
        if (root == null) return root;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            while (len-- > 0) {
                TreeNode node = queue.poll();
                swap(node);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return root;
    }
}

```

### 6.二叉树的最大深度（104）

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例： 给定二叉树 [3,9,20,null,null,15,7]

![104. 二叉树的最大深度](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203153031914-20230310121809902.png)

返回它的最大深度 3 。

```java
import java.util.Deque;
import java.util.LinkedList;

public class MaxDepth {
    // digui
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int leftMaxDepth = maxDepth(root.left);
        int rightMaxDepth = maxDepth(root.right);
        return Math.max(leftMaxDepth, rightMaxDepth) + 1;
    }

    // diedai
    public int maxDepth2(TreeNode root) {
        if (root == null)
            return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int len = deque.size();
            depth++;
            while (len-- > 0) {
                TreeNode node = deque.poll();
                if (node.left != null)
                    deque.offer(node.left);
                if (node.right != null)
                    deque.offer(node.right);
            }
        }
        return depth;
    }
}

```

### 7.二叉树的最小深度（111）

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7]

![111.二叉树的最小深度1](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020315582586.png)
返回它的最小深度

```java
// diedai
public int minDepth(TreeNode root) {
    if (root == null)
        return 0;
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offer(root);
    int depth = 0;
    boolean flag = true;
    while (flag && !deque.isEmpty()) {
        int len = deque.size();
        while (len-- > 0) {
            TreeNode node = deque.poll();
            if (node.left == null && node.right == null) {
                flag = false;
                break;
            }
            if (node.left != null)
                deque.offer(node.left);
            if (node.right != null)
                deque.offer(node.right);
        }
        depth++;
    }
    return depth;
}

// digui
public int minDepth2(TreeNode root) {
    if (root == null)
        return 0;
    int left = minDepth2(root.left);
    int right = minDepth2(root.right);
    if (root.left == null && root.right != null)
        return right + 1;
    if (root.left != null && root.right == null)
        return right + 1;
    return Math.min(left, right) + 1;
}

int result = Integer.MAX_VALUE;

public int minDepth3(TreeNode root) {
    if (root == null)
        return 0;
    getDepth(root, 1);
    return result;
}

public void getDepth(TreeNode root, int depth) {
    if (root == null)
        return;
    if (root.left == null && root.right == null)
        result = Math.min(result, depth);
    if (root.left != null)
        getDepth(root.left, depth + 1);
    if (root.right != null)
        getDepth(root.right, depth + 1);
    return;
}
```

### 8.完全二叉树的节点个数（222）

给出一个完全二叉树，求出该树的节点个数。

示例 1：

- 输入：root = [1,2,3,4,5,6]
- 输出：6

示例 2：

- 输入：root = []
- 输出：0

示例 3：

- 输入：root = [1]
- 输出：1

提示：

- 树中节点的数目范围是[0, 5 * 10^4]
- 0 <= Node.val <= 5 \* 10^4
- 题目数据保证输入的树是 完全二叉树

```java
// diedai
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offer(root);
    int count = 0;
    while (!deque.isEmpty()) {
        int len = deque.size();
        count += len;
        while (len-- > 0) {
            TreeNode node = deque.poll();
            if (node.left != null)
                deque.offer(node.left);
            if (node.right != null)
                deque.offer(node.right);
        }
    }
    return count;
}

// digui
public int countNode2(TreeNode root) {
    if (root == null)
        return 0;
    return countNode2(root.left) + countNode2(root.right) + 1;
}
```

### 9.平衡二叉树（110）

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155447919.png)

返回 false 。

```java
public boolean isBalanced(TreeNode root) {
    return helper(root) != -1;
}

public int helper(TreeNode root) {
    if (root == null)
        return 0;
    int leftHeight = helper(root.left);
    if (leftHeight == -1)
        return -1;
    int rightHeight = helper(root.right);
    if (rightHeight == -1)
        return -1;
    int diff = Math.abs(leftHeight - rightHeight);
    if (diff > 1)
        return -1;
    return Math.max(leftHeight, rightHeight) + 1;
}
```

### 10.二叉树的所有路径（257）

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:
![257.二叉树的所有路径1](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020415161576.png)

```java
import java.util.ArrayList;
import java.util.List;

class BinaryTreePaths {
    // 回溯递归
    public List<String> binaryTreePaths(TreeNode rNode) {
        List<String> ans = new ArrayList<>();
        if (rNode == null) {
            return ans;
        }
        List<Integer> paths = new ArrayList<>();
        helper(rNode, ans, paths);
        return ans;
    }

    public void helper(TreeNode rNode, List<String> ans, List<Integer> paths) {
        paths.add(rNode.val);
        if (rNode.left == null && rNode.right == null) {
            StringBuilder sb = new StringBuilder();
            int i = 0;
            for (; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(i));
            ans.add(sb.toString());
            return;
        }

        if (rNode.left != null) {
            helper(rNode.left, ans, paths);
            paths.remove(paths.size() - 1);
        }
        if (rNode.right != null) {
            helper(rNode.right, ans, paths);
            paths.remove(paths.size() - 1);
        }
    }
}
```

### 11.左叶子之和（404）

计算给定二叉树的所有左叶子之和。

示例：

![404.左叶子之和](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151927654.png)
注意！不是左节点之和，而是左叶子之和！
叶子也就是一个没有左右节点的一个节点！！！

```java
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftSum = sumOfLeftLeaves(root.left);
    int rightSum = sumOfLeftLeaves(root.right);
    if (root.left != null && root.left.left == null && root.left.right == null) {
        leftSum = root.left.val;
    }
    return leftSum + rightSum;
}
```

### 12.找树左下角的值(513)

给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:

![513.找树左下角的值](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204152956836.png)

示例 2:

![513.找树左下角的值1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204153017586.png)

```java
public int findBottomLeftValue2(TreeNode root) {
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int res = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode poll = queue.poll();
            if (i == 0) {
                res = poll.val;
            }
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
    }
    return res;
}
```

### 13.路径总和(112)路径总和 2(113)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230407210247.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

```java
import java.util.ArrayList;
import java.util.List;

public class HasPathSum {
    // 0112.路径总和
    public boolean hasPathSum(TreeNode rNode, int targetSum) {
        if (rNode == null) {
            return false;
        }
        if (rNode != null && rNode.left == null && rNode.right == null && rNode.val == targetSum) {
            return true;
        }
        if (rNode != null && rNode.left == null && rNode.right == null && rNode.val != targetSum) {
            return false;
        }
        return helper(rNode, targetSum, 0);
    }

    public boolean helper(TreeNode rNode, int targetSum, int cur) {
        if (rNode != null && rNode.left == null && rNode.right == null) {
            return targetSum == cur + rNode.val;
        }

        if (rNode.left != null) {
            cur += rNode.val;
            boolean leftSum = helper(rNode.left, targetSum, cur);
            if (leftSum) {
                return true;
            }
            cur -= rNode.val;
        }
        if (rNode.right != null) {
            cur += rNode.val;
            boolean rightSum = helper(rNode.right, targetSum, cur);
            if (rightSum) {
                return true;
            }
            cur -= rNode.val;
        }
        return false;
    }

    // 0113.路径总和2
    public List<List<Integer>> pathSum(TreeNode rNode, int targetSum) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        helper2(rNode, targetSum, ans, path, 0);
        return ans;
    }

    public void helper2(TreeNode rNode, int targetSum, List<List<Integer>> ans, List<Integer> path, int cur) {
        if (rNode.left == null && rNode.right == null) {
            if (cur + rNode.val == targetSum) {
                path.add(rNode.val);
                ans.add(new ArrayList<>(path));
                return;
            }
        }
        if (rNode.left != null) {
            path.add(rNode.val);
            cur += rNode.val;
            helper2(rNode.left, targetSum, ans, path, cur);
            cur -= rNode.val;
            path.remove(path.size() - 1);
        }
        if (rNode.right != null) {
            path.add(rNode.val);
            cur += rNode.val;
            helper2(rNode.right, targetSum, ans, path, cur);
            cur -= rNode.val;
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(5);
        TreeNode root1 = new TreeNode(4);
        TreeNode root2 = new TreeNode(8);
        TreeNode root3 = new TreeNode(11);
        TreeNode root4 = new TreeNode(7);
        TreeNode root5 = new TreeNode(2);
        TreeNode root6 = new TreeNode(13);
        TreeNode root7 = new TreeNode(4);
        TreeNode root8 = new TreeNode(1);
        root.left = root1;
        root.right = root2;
        root1.left = root3;
        root3.left = root4;
        root3.right = root5;
        root2.left = root6;
        root2.right = root7;
        root7.right = root8;
        List<List<Integer>> ans = new HasPathSum().pathSum(root, 22);
        for (List<Integer> list : ans) {
            for (Integer list2 : list) {
                System.out.println(list2);
            }
        }
    }
}

```

### 14.从中序与后序遍历序列构造二叉树(106)从前序与中序遍历序列构造二叉树(105)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

- 中序遍历 inorder = [9,3,15,20,7]
- 后序遍历 postorder = [9,15,7,20,3]
  返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154316774.png)

```java
import java.util.HashMap;
import java.util.Map;

public class BuildTree {
    // 106.从中序与后序遍历序列构造二叉树
    public TreeNode buildTreePOST(int[] inorder, int[] postorder) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return helper1(inorder, 0, inorder.length, postorder, 0, postorder.length, map);
    }

    public TreeNode helper1(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd,
            Map<Integer, Integer> map) {
        if (inStart >= inEnd || postStart >= postEnd) {
            return null;
        }
        int rootIdx = map.get(postorder[postEnd - 1]);
        TreeNode root = new TreeNode(inorder[rootIdx]);
        int leftLen = rootIdx - inStart;
        root.left = helper1(inorder, inStart, rootIdx, postorder, postStart, postStart + leftLen, map);
        root.right = helper1(inorder, rootIdx + 1, inEnd, postorder, postStart + leftLen, postEnd - 1, map);
        return root;
    }

    // 105.从前序与中序遍历序列构造二叉树
    public TreeNode buildTreePRE(int[] preorder, int[] inorder) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return helper2(inorder, 0, inorder.length, preorder, 0, preorder.length, map);
    }

    public TreeNode helper2(int[] inorder, int inStart, int inEnd, int[] preorder, int preStart, int preEnd,
            Map<Integer, Integer> map) {
        if (inStart >= inEnd || preStart >= preEnd) {
            return null;
        }
        int rootIdx = map.get(preorder[preStart]);
        TreeNode root = new TreeNode(inorder[rootIdx]);
        int leftLen = rootIdx - inStart;
        root.left = helper2(inorder, inStart, rootIdx, preorder, preStart + 1, preStart + leftLen + 1, map);
        root.right = helper2(inorder, rootIdx + 1, inEnd, preorder, preStart + leftLen + 1, preEnd, map);
        return root;
    }
}

```

### 15.最大二叉树(654)

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

示例 ：

![654.最大二叉树](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204154534796.png)

提示：

给定的数组的大小在 [1, 1000] 之间。

```java
public class ConstructMaximumBinaryTree {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums.length == 1) {
            return new TreeNode(nums[0]);
        }
        return helper(nums, 0, nums.length);
    }

    public TreeNode helper(int[] nums, int leftIndex, int rightIndex) {
        if (leftIndex >= rightIndex) {
            return null;
        }
        int maxNum = nums[leftIndex], maxIdx = leftIndex;
        for (int i = leftIndex; i < rightIndex; i++) {
            if (nums[i] > maxNum) {
                maxNum = nums[i];
                maxIdx = i;
            }
        }
        TreeNode node = new TreeNode(maxNum);
        node.left = helper(nums, leftIndex, maxIdx);
        node.right = helper(nums, maxIdx + 1, rightIndex);
        return node;
    }
}

```

### 16.合并二叉树(617)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为  NULL 的节点将直接作为新二叉树的节点。

示例  1:

![617.合并二叉树](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000854.png)

注意: 合并必须从两个树的根节点开始。

```java
public class MergeTrees {
    public TreeNode mergeTrees(TreeNode node1, TreeNode node2) {
        if (node1 == null) {
            return node2;
        }
        if (node2 == null) {
            return node1;
        }
        TreeNode root = new TreeNode(node1.val + node2.val);
        root.left = mergeTrees(node1.left, node2.left);
        root.right = mergeTrees(node1.right, node2.right);
        return root;
    }
}

```

### 17.二叉搜索数中的搜索(700)

给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，

![700.二叉搜索树中的搜索](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204155522476.png)

在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

```java
public class SearchBST {
    public TreeNode searchBST(TreeNode rNode, int val) {
        if (rNode.val == val) {
            return rNode;
        }
        if (rNode.val < val) {
            return searchBST(rNode.right, val);
        } else {
            return searchBST(rNode.left, val);
        }
    }
}
```

### 18.验证二叉搜索树(98)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

![98.验证二叉搜索树](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000750.png)

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class IsValidBST {
    public boolean isValidBST(TreeNode rNode) {
        return helper(rNode, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    public boolean helper(TreeNode rNode, int min, int max) {
        if (rNode == null) {
            return true;
        }
        if (rNode.val <= min || rNode.val >= max) {
            return false;
        }
        return helper(rNode.left, min, rNode.val) && helper(rNode.right, rNode.val, max);
    }

    // 中序遍历，从小到大排序
    public boolean isValidBSTINORDER(TreeNode rNode) {
        if (rNode == null) {
            return true;
        }
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(rNode);
        int pre = Integer.MIN_VALUE;
        while (!st.isEmpty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop();
                if (node.right != null) {
                    st.push(node.right);
                }
                st.push(node);
                st.push(null);
                if (node.left != null) {
                    st.push(node.left);
                }
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                if (node.val < pre) {
                    return false;
                }
                pre = node.val;
            }
        }
        return true;
    }
}

```

### 19.二叉搜索树的最小绝对差(530)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

![530二叉搜索树的最小绝对差](https://code-thinking-1253855093.file.myqcloud.com/pics/20201014223400123.png)

提示：树中至少有 2 个节点。

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class GetMinimumDiff {
    public int getMinimumDiff(TreeNode rNode) {
        int ans = Integer.MAX_VALUE;
        helper(rNode, null, ans);
        return ans;
    }

    public void helper(TreeNode rNode, TreeNode pre, int ans) {
        if (rNode == null) {
            return;
        }
        helper(rNode.left, pre, ans);
        if (pre != null) {
            ans = Math.min(ans, Math.abs(rNode.val - pre.val));
        }
        pre = rNode;
        helper(rNode.right, pre, ans);
    }

    // 中序遍历迭代
    public int getMinimumDiff2(TreeNode rNode) {
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(rNode);
        int ans = Integer.MAX_VALUE;
        TreeNode pre = null;
        while (!st.isEmpty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop();
                if (node.right != null) {
                    st.push(node.right);
                }
                st.push(node);
                st.push(null);
                if (node.left != null) {
                    st.push(node.left);
                }
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                if (pre != null) {
                    ans = Math.min(ans, Math.abs(pre.val - node.val));
                }
                pre = node;
            }
        }
        return ans;
    }
}

```

### 20.二叉搜索树中的众数

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

给定 BST [1,null,2,2],

![501. 二叉搜索树中的众数](https://code-thinking-1253855093.file.myqcloud.com/pics/20201014221532206.png)

返回[2].

提示：如果众数超过 1 个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class FindMode {
    public int[] findMode(TreeNode rNode) {
        List<Integer> list = new ArrayList<>();
        int maxCount = 0, count = 0;
        TreeNode tmp = null;
        Deque<TreeNode> st = new ArrayDeque<>();
        if (rNode != null) {
            st.push(rNode);
        }
        while (!st.isEmpty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop();
                if (node.right != null) {
                    st.push(node.right);
                }
                st.push(node);
                st.push(null);
                if (node.left != null) {
                    st.push(node.left);
                }
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                if (tmp == null) {
                    tmp = node;
                    count = 1;
                } else if (tmp != null && tmp.val == node.val) {
                    count++;
                } else {
                    count = 1;
                }
                if (count == maxCount) {
                    list.add(node.val);
                }
                if (count > maxCount) {
                    maxCount = count;
                    list.clear();
                    list.add(node.val);
                }
            }
        }
        int[] result = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }
}

```

### 21.二叉树的最近公共祖先(236)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![236. 二叉树的最近公共祖先](https://code-thinking-1253855093.file.myqcloud.com/pics/20201016173414722.png)

示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例  2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

主要思路：
首先！！！
遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。

那么二叉树如何可以自底向上查找呢？

回溯啊，二叉树回溯的过程就是从低到上。

后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。

接下来就看如何判断一个节点是节点 q 和节点 p 的公共祖先呢。

两个节点 p 和 q，他们的位置所在关系只有四种：

- 同时在根节点的左子树上
- 同时在根节点的右子树上
- 分别在根节点的左、右子树上
- 可能有一个就是根节点

因此我们可以得到以下三个关系式和判断关系：

```java
1. if (p == root || q == root) return root;//其中一个节点就是根节点
2. TreeNode left = lowestCommonAncestor(root.left, p, q)
3. TreeNode right = lowestCommonAncestor(root.right, p, q);
4. if (left != null && right == null) return left;//说明两个节点都是在左子树上
5. if (left == null && right != null) return right;//说明两个节点都在右子树上
6. if (left != null && right != null) return root;//说明两个节点分别在根节点的左、右子树上
```

```java
public class LowestCommonAncestor {
    public TreeNode lowestCommonAncestor(TreeNode rNode, TreeNode p, TreeNode q) {
        if (rNode == null) {
            return null;
        }
        if (rNode == p || rNode == q) {
            return rNode;
        }
        TreeNode lefTreeNode = lowestCommonAncestor(rNode.left, p, q);
        TreeNode righTreeNode = lowestCommonAncestor(rNode.right, p, q);
        if (lefTreeNode == null && righTreeNode != null) {
            return righTreeNode;
        } else if (lefTreeNode != null && righTreeNode == null) {
            return lefTreeNode;
        } else {
            return rNode;
        }
    }
}

```

### 22.二叉搜索树的最近公共祖先(235)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![235. 二叉搜索树的最近公共祖先](https://code-thinking-1253855093.file.myqcloud.com/pics/20201018172243602.png)

示例 1:

- 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
- 输出: 6
- 解释: 节点 2 和节点 8 的最近公共祖先是 6。

示例 2:

- 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
- 输出: 2
- 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

思路：
做过二叉树：公共祖先问题题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有 p，右子树里有 q，那么当前节点就是最近公共祖先。

那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。

在有序树里，如果判断一个节点的左子树里有 p，右子树里有 q 呢？

因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 > p && 中节点 < q 或者 中节点 > q && 中节点 < p。

那么只要从上到下去遍历，遇到 cur 节点是数值在[p, q]区间中则一定可以说明该节点 cur 就是 q 和 p 的公共祖先。

当我们从上向下去递归遍历，第一次遇到 cur 节点是数值在[p, q]区间中，那么 cur 就是 p 和 q 的最近公共祖先。

```java
public class LowestCommonAncestorBST {
    public TreeNode lowestCommonAncestorBST(TreeNode rNode, TreeNode p, TreeNode q) {
        //如果是按照不是BST进行解题的话，就是从下自上依次找父节点，后序遍历
        // if (rNode == p || rNode == q || rNode == null) return rNode;
        // TreeNode left = lowestCommonAncestorBST(rNode.left, p, q);
        // TreeNode right = lowestCommonAncestorBST(rNode.right, p, q);
        // if (left == null && right != null) return right;
        // else if (left != null && right == null) return left;
        // else
        //     return rNode;

        //现在是一个BST树，所有的数字都是有序的
        if (rNode == p || rNode == q || rNode == null) {
            return rNode;
        }

        //p，q在root节点右侧
        if (rNode.val < p.val && rNode.val < q.val) {
            TreeNode right = lowestCommonAncestorBST(rNode.right, p, q);
            if (right != null) {
                return right;
            }
        }

        //p，q在root节点左侧
        if (rNode.val > p.val && rNode.val > q.val) {
            TreeNode left = lowestCommonAncestorBST(rNode.left, p, q);
            if (left != null) {
                return left;
            }
        }

        // p,q在root节点两侧
        return rNode;
    }
}

```
